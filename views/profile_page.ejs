<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SpyThere - Profile</title>
  <link rel="stylesheet" href="/home_page.css">
</head>
<body class="profile-page">

  <!-- Header -->
  <%- include('partials/header') %>

  <div class="app-layout">
    <!-- Navbar -->
    <%- include('partials/navbar') %>

    <!-- Main Content -->
    <div class="main-content">
      
      <!-- Profile Information Section -->
      <div class="profile-info-container">
        <div class="profile-picture">
          <img src="/images/profile-placeholder.png" alt="Profile Picture">
        </div>
        <div class="profile-details">
          <div class="profile-header">
            <h2><%= username %>'s Profile</h2>
            <span class="profile-email"><%= email %></span>
            <button id="edit-profile-btn" class="edit-profile-btn">Edit Profile</button>
          </div>
          
          <% if (typeof error !== 'undefined' && error) { %>
            <div class="error-message">
              <%= error %>
            </div>
          <% } %>
          
          <% if (typeof success !== 'undefined' && success) { %>
            <div class="success-message">
              <%= success %>
            </div>
          <% } %> 
        </div>
      </div>

      <!-- Posts List Section (todo list inspired)-->
      <div class="todo-container">
        <h2><%= username %>'s Posts</h2>
        <ul>
          <% if (posts.length > 0) { %>
            <% posts.forEach(post => { %>
              <li data-post-id="<%= post.id %>">
                <strong><%= post.username %></strong>
                <div class="post-content">
                  <% if (post.value && typeof post.value==='string' && post.value.trim().length> 0) { %>
                    <div class="truncated-text">
                      <%= post.value %>
                    </div>
                    <span class="see-more-btn">See more...</span>
                    <% } %>
                      </div>
                      <% if (post.mediaUrl) { %>
                        <% if (post.mediaUrl.match(/\.(jpeg|jpg|png|gif)$/i)) { %>
                          <div class="media-container">
                            <img src="<%= post.mediaUrl %>" alt="Post media" class="post-media">
                          </div>
                          <% } else if (post.mediaUrl.match(/\.(mp4|webm|ogg)$/i)) { %>
                            <div class="media-container">
                              <video controls class="post-media">
                                <source src="<%= post.mediaUrl %>">
                                Your browser does not support the video tag.
                              </video>
                            </div>
                            <% } %>
                              <% } %>
                <div class="post-reactions">
                  <div class="like-wrapper">
                    <img src="/assets/Like_Icon.png" alt="Like" class="reaction-icon like-btn" data-liked="false"
                      data-post-id="<%= post.id %>">
                    <span class="like-count" data-post-id="<%= post.id %>">0</span>
                  </div>
                  <div class="comment-wrapper">
                    <img src="/assets/Comment_Icon.png" alt="Comment" class="reaction-icon comment-btn">
                    <span class="comment-count" data-post-id="<%= post.id %>">0</span>
                  </div>
                  <img src="/assets/Share_Icon.png" alt="Share" class="reaction-icon">
                  <div class="post-actions-container">
                    <img src="/assets/Edit_Icon.png" alt="Edit" class="reaction-icon edit-post-btn">
                    <img src="/assets/Delete_Icon.png" alt="Delete" class="reaction-icon delete-post-btn">
                    </div>
                </div>
              </li>
            <% }) %>
          <% } else { %>
            <li>No posts to show.</li>
          <% } %>
        </ul>
      </div>

      <!-- Modal for Edit Post -->
      <div id="edit-post-modal" class="modal">
        <div class="modal-content">
          <button id="close-edit-post-modal" class="close-modal">×</button>
          <h3>Edit Post</h3>
      
          <form id="edit-post-form">
            <input type="hidden" id="edit-post-id" name="postId">
      
            <textarea id="edit-post-text" name="text" placeholder="Edit your post..."></textarea>
      
            <div class="modal-btns">
              <button type="button" id="cancel-edit-post-btn" class="modal-btn">Cancel</button>
              <button type="submit" class="modal-btn">Save Changes</button>
            </div>
          </form>
        </div>
      </div>
      
      <!-- Modal for Delete Post Confirmation -->
      <div id="delete-post-confirm-modal" class="modal">
        <div class="modal-content">
          <h3>Delete Post</h3>
          <p>Are you sure you want to delete this post? This action cannot be undone.</p>
      
          <input type="hidden" id="delete-post-id">
      
          <div class="delete-modal-buttons">
            <button id="cancel-delete-post-btn" class="modal-btn cancel-btn">Cancel</button>
            <button id="confirm-delete-post-btn" class="modal-btn delete-btn">Delete</button>
          </div>
        </div>
      </div>

      <!-- Modal for Adding Post -->
      <div id="post-modal">
        <div id="modal-content">
          <form action="/submit-post" method="post" id="post-form" enctype="multipart/form-data">
            <h1>Create to Web</h1>
            <textarea name="post" id="post" placeholder="What's on your mind..."></textarea>
            <div class="custom-file-input">
              <label class="file-input-label">
                <img src="/assets/Add_Image_Icon.png" alt="Add Image" title="Upload an image or video">
                <input type="file" name="media" accept="image/*,video/*,image/gif">
              </label>
              <span class="file-name"></span>
            </div>
            <div id="modal-btns">
              <button id="close-modal-btn" class="modal-btn" type="button">Cancel</button>
              <input type="submit" value="Post" id="post-content-btn" class="modal-btn">
            </div>
          </form>
        </div>
      </div>
      
      <!-- Modal for Edit Profile -->
      <div id="edit-profile-modal">
        <div class="modal-content">
          <h1>Edit Profile</h1>
          <form action="/update-profile" method="post" id="edit-profile-form">
            <div class="form-group">
              <label for="edit-username">Username</label>
              <input type="text" id="edit-username" name="username" value="<%= username %>" required>
            </div>
            
            <div class="form-group">
              <label for="edit-email">Email</label>
              <input type="email" id="edit-email" name="email" value="<%= email %>" required>
            </div>
            
            <div class="form-group">
              <label for="current-password">Current Password (required to save changes)</label>
              <div class="password-container">
                <input type="password" id="current-password" name="currentPassword" required>
                <button type="button" class="toggle-password" onclick="togglePassword('current-password')">
                  <img src="/assets/eye.svg" alt="Toggle password visibility" id="current-password-toggle-icon">
                </button>
              </div>
            </div>
            
            <div class="modal-btns">
              <button id="close-edit-modal-btn" class="modal-btn" type="button">Cancel</button>
              <input type="submit" value="Save Changes" class="modal-btn">
            </div>
          </form>
        </div>
      </div>
<!-- Modal for Comments -->
<div class="comment-modal">
  <div class="comment-modal-content">
    <button class="close-comment-modal">×</button>
    <h3>Comments <span class="modal-comment-count">0</span></h3>

    <!-- Comment Input Section -->
    <div class="comment-input-section">
      <textarea placeholder="Write a comment..."></textarea>
      <div class="comment-actions">
        <button type="button" class="modal-btn">Cancel</button>
        <button type="button" class="modal-btn">Post Comment</button>
      </div>
    </div>

    <div class="comment-divider"></div>

    <!-- Comment List Section -->
    <div class="comment-list-section">
      <div class="loading-comments">Loading comments</div>
    </div>
  </div>
</div>

<!-- Modal for Likes -->
<div class="like-modal">
  <div class="like-modal-content">
    <button class="close-like-modal">×</button>
    <h3>Likes <span class="modal-like-count">0</span></h3>

    <div class="like-divider"></div>

    <!-- Like List Section -->
    <div class="like-list-section">
      <div class="loading-likes">Loading likes</div>
    </div>
  </div>
</div>

<!-- Modal for Edit Comment -->
<div id="edit-comment-modal" class="modal">
  <div class="modal-content">
    <button id="close-edit-comment-modal" class="close-modal">×</button>
    <h3>Edit Comment</h3>

    <form id="edit-comment-form">
      <input type="hidden" id="edit-comment-id" name="commentId">
      <input type="hidden" id="edit-comment-post-id" name="postId">

      <textarea id="edit-comment-text" name="text" placeholder="Edit your comment..."></textarea>

      <div class="modal-btns">
        <button type="button" id="cancel-edit-comment-btn" class="modal-btn">Cancel</button>
        <button type="submit" class="modal-btn">Save Changes</button>
      </div>
    </form>
  </div>
</div>

<!-- Modal for Delete Confirmation -->
<div id="delete-confirm-modal" class="modal">
  <div class="modal-content">
    <h3>Delete Comment</h3>
    <p>Are you sure you want to delete this comment? This action cannot be undone.</p>

    <input type="hidden" id="delete-comment-id">
    <input type="hidden" id="delete-comment-post-id">

    <div class="delete-modal-buttons">
      <button id="cancel-delete-btn" class="modal-btn cancel-btn">Cancel</button>
      <button id="confirm-delete-btn" class="modal-btn delete-btn">Delete</button>
    </div>
  </div>
</div>
    </div>
  </div>

  <script src="/scripts/index.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Post edit and delete functionality
      const editPostBtns = document.querySelectorAll('.edit-post-btn');
      const deletePostBtns = document.querySelectorAll('.delete-post-btn');
      const editPostModal = document.getElementById('edit-post-modal');
      const closeEditPostBtn = document.getElementById('close-edit-post-modal');
      const cancelEditPostBtn = document.getElementById('cancel-edit-post-btn');
      const editPostForm = document.getElementById('edit-post-form');
      const deletePostConfirmModal = document.getElementById('delete-post-confirm-modal');
      const cancelDeletePostBtn = document.getElementById('cancel-delete-post-btn');
      const confirmDeletePostBtn = document.getElementById('confirm-delete-post-btn');

      // Comment-related elements
      const commentModal = document.querySelector('.comment-modal');
      const closeCommentBtn = document.querySelector('.close-comment-modal');
      const cancelCommentBtn = document.querySelector('.comment-actions .modal-btn:first-child');
      const postCommentBtn = document.querySelector('.comment-actions .modal-btn:last-child');
      const commentListSection = document.querySelector('.comment-list-section');
      const modalCommentCount = document.querySelector('.modal-comment-count');
      const editCommentModal = document.getElementById('edit-comment-modal');
      const deleteConfirmModal = document.getElementById('delete-confirm-modal');
      let currentPostId = null;

      // Function to create comment element
      function createCommentElement(comment) {
        const commentElement = document.createElement('div');
        commentElement.className = 'comment-item';
        commentElement.dataset.commentId = comment.id;

        const isOwnComment = comment.author === '<%= username %>';

        // Check if comment text is longer than 150 characters
        const commentText = comment.text;
        const needsTruncation = commentText.length > 150;

        let commentHTML = `
          <div class="comment-author">${comment.author}</div>
        `;

        if (needsTruncation) {
          commentHTML += `
            <div class="comment-text truncated-text">${commentText}</div>
            <span class="comment-see-more">See more...</span>
          `;
        } else {
          commentHTML += `
            <div class="comment-text">${commentText}</div>
          `;
        }

        const actionButtons = isOwnComment ? `
          <div class="comment-actions-container">
            <img src="/assets/Edit_Icon.png" alt="Edit" class="comment-action-icon edit-comment-btn" data-comment-id="${comment.id}">
            <img src="/assets/Delete_Icon.png" alt="Delete" class="comment-action-icon delete-comment-btn" data-comment-id="${comment.id}">
          </div>
        ` : '';

        commentHTML += actionButtons;
        commentElement.innerHTML = commentHTML;

        // Add event listeners for edit and delete buttons if it's the user's own comment
        if (isOwnComment) {
          const editBtn = commentElement.querySelector('.edit-comment-btn');
          const deleteBtn = commentElement.querySelector('.delete-comment-btn');

          if (editBtn) {
            editBtn.onclick = function (e) {
              e.preventDefault();
              e.stopPropagation();
              const commentId = this.getAttribute('data-comment-id');
              const commentText = comment.text; // Use the original comment text
              handleEditComment(commentId, commentText);
            };
          }

          if (deleteBtn) {
            deleteBtn.onclick = function (e) {
              e.preventDefault();
              e.stopPropagation();
              const commentId = this.getAttribute('data-comment-id');
              handleDeleteComment(commentId);
            };
          }
        }

        // Add see more functionality if needed
        if (needsTruncation) {
          setTimeout(() => {
            const seeMoreBtn = commentElement.querySelector('.comment-see-more');
            const commentTextDiv = commentElement.querySelector('.comment-text');

            if (seeMoreBtn && commentTextDiv) {
              seeMoreBtn.addEventListener('click', function () {
                commentTextDiv.classList.toggle('expanded');
                this.textContent = commentTextDiv.classList.contains('expanded') ? 'See less' : 'See more...';
              });
            }
          }, 0);
        }

        return commentElement;
      }

      // Handle editing a comment
      function handleEditComment(commentId, currentText) {
        const editCommentTextarea = document.getElementById('edit-comment-text');
        const commentIdInput = document.getElementById('edit-comment-id');
        const postIdInput = document.getElementById('edit-comment-post-id');

        if (!editCommentTextarea || !commentIdInput || !postIdInput) {
          console.error('Required modal elements not found');
          return;
        }

        editCommentTextarea.value = currentText;
        commentIdInput.value = commentId;
        postIdInput.value = currentPostId;

        editCommentModal.style.display = 'block';
        editCommentTextarea.focus();
      }

      // Handle deleting a comment
      function handleDeleteComment(commentId) {
        const deleteCommentIdInput = document.getElementById('delete-comment-id');
        const deleteCommentPostIdInput = document.getElementById('delete-comment-post-id');

        if (!deleteCommentIdInput || !deleteCommentPostIdInput) {
          console.error('Required delete modal elements not found');
          return;
        }

        deleteCommentIdInput.value = commentId;
        deleteCommentPostIdInput.value = currentPostId;

        deleteConfirmModal.style.display = 'block';
      }

      // Function to initialize all post event listeners
      function initializePostEventListeners(postItem) {
        const postId = postItem.dataset.postId;

        // Initialize like button
        const likeBtn = postItem.querySelector('.like-btn');
        if (likeBtn) {
          likeBtn.addEventListener('click', async function (e) {
            e.preventDefault();
            e.stopPropagation();
        
            const isLiked = this.dataset.liked === 'true';

            try {
              const response = await fetch('/api/likes', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  postId: postId,
                  liked: !isLiked
                })
              });

              if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Server returned ${response.status}: ${errorText}`);
              }

              const data = await response.json();

              this.dataset.liked = !isLiked ? 'true' : 'false';
              this.src = !isLiked ? '/assets/Liked_Icon.png' : '/assets/Like_Icon.png';
              this.alt = !isLiked ? 'Unlike' : 'Like';

              const likeCount = postItem.querySelector('.like-count');
              if (likeCount) {
                likeCount.textContent = data.likeCount;
              }
            } catch (error) {
              console.error('Error updating like:', error);
              alert(`Failed to update like: ${error.message}`);
            }
          });
        }

        // Initialize comment button
        const commentBtn = postItem.querySelector('.comment-btn');
        if (commentBtn) {
          commentBtn.addEventListener('click', function () {
            currentPostId = postId;
            console.log('Opening comments for post:', currentPostId);
            commentModal.style.display = 'block';

            commentListSection.innerHTML = '';
            const loadingMsg = document.createElement('div');
            loadingMsg.className = 'loading-comments';
            loadingMsg.textContent = 'Loading comments';
            commentListSection.appendChild(loadingMsg);

            fetchComments(currentPostId);
          });
        }

        // Initialize edit button
        const editBtn = postItem.querySelector('.edit-post-btn');
        if (editBtn) {
          editBtn.addEventListener('click', function () {
            const postText = Array.from(postItem.childNodes)
              .filter(node => node.nodeType === Node.TEXT_NODE)
              .map(node => node.textContent.trim())
              .join('')
              .trim();

            document.getElementById('edit-post-id').value = postId;
            document.getElementById('edit-post-text').value = postText;
            editPostModal.style.display = 'block';
          });
        }

        // Initialize delete button
        const deleteBtn = postItem.querySelector('.delete-post-btn');
        if (deleteBtn) {
          deleteBtn.addEventListener('click', function () {
            document.getElementById('delete-post-id').value = postId;
            deletePostConfirmModal.style.display = 'block';
          });
        }
      }

      // Initialize all posts' event listeners on page load
      document.querySelectorAll('.todo-container li').forEach(postItem => {
        initializePostEventListeners(postItem);
      });

      // Close edit post modal
      function closeEditPostModal() {
        editPostModal.style.display = 'none';
      }

      if (closeEditPostBtn) {
        closeEditPostBtn.addEventListener('click', closeEditPostModal);
      }

      if (cancelEditPostBtn) {
        cancelEditPostBtn.addEventListener('click', closeEditPostModal);
      }

      // Close modal when clicking outside
      window.addEventListener('click', function (e) {
        if (e.target === editPostModal) {
          closeEditPostModal();
        }
      });

      // Handle edit post form submission
      if (editPostForm) {
        editPostForm.addEventListener('submit', async function (e) {
          e.preventDefault();

          const postId = document.getElementById('edit-post-id').value;
          const postText = document.getElementById('edit-post-text').value.trim();

          if (!postText) {
            console.error('Post cannot be empty');
            return;
          }

          try {
            // Submit the edited post
            const response = await fetch(`/api/posts/${postId}`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                value: postText
              })
            });

            console.log('Edit post response status:', response.status);

            if (!response.ok) {
              const errorText = await response.text();
              console.error('Server error response:', errorText);
              throw new Error(`Server returned ${response.status}: ${errorText}`);
            }

            const updatedPost = await response.json();
            console.log('Post updated successfully:', updatedPost);

            // Update the post in the UI
            const postItem = document.querySelector(`li[data-post-id="${postId}"]`);
            if (postItem) {
              // Store the original username element
              const originalUsername = postItem.querySelector('strong').outerHTML;
              const mediaElement = postItem.querySelector('.media-container');
              const reactionsDiv = postItem.querySelector('.post-reactions');

              // Create a temporary div to hold the structure
              const tempDiv = document.createElement('div');
              tempDiv.innerHTML = originalUsername;

              // Create the post-content with truncated text and see more button
              const postContent = document.createElement('div');
              postContent.className = 'post-content';

              // Only add text and see more button if there is text content
              if (postText && postText.trim().length > 0) {
                const truncatedText = document.createElement('div');
                truncatedText.className = 'truncated-text';
                truncatedText.textContent = postText;

                const seeMoreBtn = document.createElement('span');
                seeMoreBtn.className = 'see-more-btn';
                seeMoreBtn.textContent = 'See more...';

                // If text is less than 150 characters, hide the see more button
                if (postText.length < 150) {
                  seeMoreBtn.classList.add('hidden');
                }

                // Add click event to see more button
                seeMoreBtn.addEventListener('click', function () {
                  truncatedText.classList.toggle('expanded');
                  this.textContent = truncatedText.classList.contains('expanded') ? 'See less' : 'See more...';
                });

                postContent.appendChild(truncatedText);
                postContent.appendChild(seeMoreBtn);
              }

              tempDiv.appendChild(postContent);

              // Re-add the media element if it exists
              if (mediaElement) {
                tempDiv.appendChild(mediaElement);
              }

              // Re-add the reactions div
              if (reactionsDiv) {
                tempDiv.appendChild(reactionsDiv);
              }
              
              // Clear the post item and add the updated content
              postItem.innerHTML = '';
              while (tempDiv.firstChild) {
                postItem.appendChild(tempDiv.firstChild);
              }
              
              // Re-initialize all event listeners for the post
              initializePostEventListeners(postItem);
            }

            // Close the modal
            closeEditPostModal();

          } catch (error) {
            console.error('Error updating post:', error);
            closeEditPostModal();
          }
        });
      }

      // Function to update comment count
      function updateCommentCount(postId, count) {
        const countElement = document.querySelector(`.comment-count[data-post-id="${postId}"]`);
        if (countElement) {
          countElement.textContent = count;
        }
      }

      // Function to initialize comment posting functionality
      function initializeCommentPosting() {
        const postCommentBtn = document.querySelector('.comment-actions .modal-btn:last-child');
        if (postCommentBtn) {
          // Remove any existing event listeners
          const newPostCommentBtn = postCommentBtn.cloneNode(true);
          postCommentBtn.parentNode.replaceChild(newPostCommentBtn, postCommentBtn);

          newPostCommentBtn.addEventListener('click', async function () {
            const commentTextarea = document.querySelector('.comment-input-section textarea');
            const commentText = commentTextarea.value.trim();
          
            if (commentText === '' || !currentPostId) {
              console.log('Empty comment or no post ID');
              return;
            }
            
            console.log('Posting comment to post:', currentPostId);

            try {
              // Show posting indicator
              newPostCommentBtn.disabled = true;
              newPostCommentBtn.textContent = 'Posting...';
            
              // Send comment to server
              const response = await fetch('/api/comments', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  postId: currentPostId,
                  text: commentText
                })
              });

              console.log('Response status:', response.status);

              if (!response.ok) {
                const errorData = await response.text();
                console.error('Server error response:', errorData);
                throw new Error(`Server returned ${response.status}: ${errorData}`);
              }

              const newComment = await response.json();
              console.log('Comment posted successfully:', newComment);

              // Clear any "no comments" message
              const noCommentsMsg = commentListSection.querySelector('.no-comments-message');
              if (noCommentsMsg) {
                commentListSection.removeChild(noCommentsMsg);
              }
              
              // Add to UI
              const newCommentElement = createCommentElement(newComment);
              commentListSection.prepend(newCommentElement);

              // Clear the input
              commentTextarea.value = '';

              // Update comment count
              const currentCount = parseInt(modalCommentCount.textContent.replace(/[()]/g, '')) || 0;
              const newCount = currentCount + 1;
              modalCommentCount.textContent = `(${newCount})`;
              updateCommentCount(currentPostId, newCount);

            } catch (error) {
              console.error('Error posting comment:', error);
              alert(`Failed to post comment: ${error.message}`);
            } finally {
              // Reset button state
              newPostCommentBtn.disabled = false;
              newPostCommentBtn.textContent = 'Post Comment';
            }
          });
        }
      }

      // Initialize comment posting on page load
      initializeCommentPosting();

      // Delete post functionality
      function closeDeletePostModal() {
        deletePostConfirmModal.style.display = 'none';
      }

      if (cancelDeletePostBtn) {
        cancelDeletePostBtn.addEventListener('click', closeDeletePostModal);
      }

      // Close modal when clicking outside
      window.addEventListener('click', function (e) {
        if (e.target === deletePostConfirmModal) {
          closeDeletePostModal();
        }
      });

      // Handle confirm delete button click
      if (confirmDeletePostBtn) {
        confirmDeletePostBtn.addEventListener('click', async function () {
          const postId = document.getElementById('delete-post-id').value;

          if (!postId) {
            console.error('Missing post information');
            return;
          }

          console.log('Sending delete request for post:', postId);
          try {
            const response = await fetch(`/api/posts/${postId}`, {
              method: 'DELETE',
              headers: {
                'Content-Type': 'application/json',
              }
            });

            console.log('Delete post response status:', response.status);

            if (!response.ok) {
              const errorText = await response.text();
              console.error('Server error response:', errorText);
              throw new Error(`Server returned ${response.status}: ${errorText}`);
            }

            const result = await response.json();
            console.log('Post deleted successfully:', result);

            // Remove post from UI
            const postItem = document.querySelector(`li[data-post-id="${postId}"]`);
            if (postItem) {
              postItem.remove();

              // Check if there are no posts left
              const remainingPosts = document.querySelectorAll('.todo-container ul li');
              if (remainingPosts.length === 0) {
                const noPostsMsg = document.createElement('li');
                noPostsMsg.textContent = 'No posts to show.';
                document.querySelector('.todo-container ul').appendChild(noPostsMsg);
              }
            }

            // Close the modal
            closeDeletePostModal();

          } catch (error) {
            console.error('Error deleting post:', error);
            alert(`Failed to delete post: ${error.message}`);
            closeDeletePostModal();
          }
        });
      }

      // Edit Profile Modal Functionality
      const editProfileBtn = document.getElementById('edit-profile-btn');
      const editProfileModal = document.getElementById('edit-profile-modal');
      const closeEditModalBtn = document.getElementById('close-edit-modal-btn');
      
      // Open modal when edit button is clicked
      if (editProfileBtn && editProfileModal) {
        editProfileBtn.addEventListener('click', function() {
          editProfileModal.style.display = 'block';
          document.body.style.overflow = 'hidden'; // Prevent scrolling
        });
      }
      
      // Close modal when cancel button is clicked
      if (closeEditModalBtn) {
        closeEditModalBtn.addEventListener('click', function() {
          editProfileModal.style.display = 'none';
          document.body.style.overflow = 'auto'; // Allow scrolling
        });
      }
      
      // Close modal when clicking outside
      window.addEventListener('click', function(e) {
        if (e.target === editProfileModal) {
          editProfileModal.style.display = 'none';
          document.body.style.overflow = 'auto'; // Allow scrolling
        }
      });
      
      // Handle form submission with validation
      const editProfileForm = document.getElementById('edit-profile-form');
      if (editProfileForm) {
        editProfileForm.addEventListener('submit', function(e) {
          const username = document.getElementById('edit-username').value.trim();
          const email = document.getElementById('edit-email').value.trim();
          
          if (!username || username.length < 3) {
            e.preventDefault();
            alert('Username must be at least 3 characters long');
            return;
          }
          
          if (!email || !email.includes('@') || !email.includes('.')) {
            e.preventDefault();
            alert('Please enter a valid email address');
            return;
          }
        });
      }

      // Initialize like functionality
      async function initializeLikeFunctionality() {
        // Check if the like API is available
        async function checkLikeApiAvailability() {
          try {
            const response = await fetch('/api/likes/test-availability');
            const isAvailable = response.status !== 404 || (await response.text()).includes('Post ID');
            return isAvailable;
          } catch (error) {
            console.warn('Like API not available:', error);
            return false;
          }
        }

        // Update like count for a specific post
        function updateLikeCount(postId, count) {
          const countElement = document.querySelector(`.like-count[data-post-id="${postId}"]`);
          if (countElement) {
            countElement.textContent = count;
          }
        }

        const isLikeApiAvailable = await checkLikeApiAvailability();
        console.log('Like API available:', isLikeApiAvailable);

        if (!isLikeApiAvailable) {
          document.querySelectorAll('.like-count').forEach(el => el.style.display = 'none');
          return;
        }

        const likeBtns = document.querySelectorAll('.like-btn');
        const likeModal = document.querySelector('.like-modal');
        const closeLikeBtn = document.querySelector('.close-like-modal');
        const likeListSection = document.querySelector('.like-list-section');
        const modalLikeCount = document.querySelector('.modal-like-count');

        let currentLikePostId = null;

        // Remove any existing event listeners
        likeBtns.forEach(btn => {
          const newBtn = btn.cloneNode(true);
          btn.parentNode.replaceChild(newBtn, btn);
        });

        // Get the fresh references after replacing the buttons
        const freshLikeBtns = document.querySelectorAll('.like-btn');

        // Toggle like status when like icon is clicked
        freshLikeBtns.forEach(btn => {
          btn.addEventListener('click', async function (e) {
            e.preventDefault();
            e.stopPropagation();

            const postItem = this.closest('li');
            const postId = postItem.dataset.postId;
            const isLiked = this.dataset.liked === 'true';

            console.log('Like button clicked for post:', postId, 'Current liked status:', isLiked);

            try {
              const response = await fetch('/api/likes', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  postId: postId,
                  liked: !isLiked
                })
              });

              if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Server returned ${response.status}: ${errorText}`);
              }

              const data = await response.json();
              console.log('Like updated:', data);

              this.dataset.liked = !isLiked ? 'true' : 'false';

              if (!isLiked) {
                this.src = '/assets/Liked_Icon.png';
                this.alt = 'Unlike';
              } else {
                this.src = '/assets/Like_Icon.png';
                this.alt = 'Like';
              }

              updateLikeCount(postId, data.likeCount);

            } catch (error) {
              console.error('Error updating like:', error);
              alert(`Failed to update like: ${error.message}`);
            }
          });
        });

        // Initialize likes
        async function initializeLikes() {
          const likeCountElements = document.querySelectorAll('.like-count');

          likeCountElements.forEach(async (countElement) => {
            const postId = countElement.dataset.postId;
            if (postId) {
              try {
                const encodedPostId = encodeURIComponent(postId);
                const response = await fetch(`/api/likes/${encodedPostId}`);

                if (!response.ok) {
                  const errorText = await response.text();
                  console.error(`Server returned ${response.status} for post ${postId}:`, errorText);
                  return;
                }

                const data = await response.json();

                const likeCount = data.likes ? data.likes.length : 0;
                countElement.textContent = likeCount;

                if (data.userLiked) {
                  const likeBtn = document.querySelector(`.like-btn[data-post-id="${postId}"]`);
                  if (likeBtn) {
                    likeBtn.src = '/assets/Liked_Icon.png';
                    likeBtn.alt = 'Unlike';
                    likeBtn.dataset.liked = 'true';
                  }
                }
              } catch (error) {
                console.error(`Error fetching like data for post ${postId}:`, error);
              }
            }
          });
        }

        initializeLikes();
      }

      // Initialize comment functionality
      function initializeCommentFunctionality() {
        const commentBtns = document.querySelectorAll('.comment-btn');
        const commentModal = document.querySelector('.comment-modal');
        const closeCommentBtn = document.querySelector('.close-comment-modal');
        const cancelCommentBtn = document.querySelector('.comment-actions .modal-btn:first-child');
        const postCommentBtn = document.querySelector('.comment-actions .modal-btn:last-child');
        const commentListSection = document.querySelector('.comment-list-section');
        const modalCommentCount = document.querySelector('.modal-comment-count');
        const editCommentModal = document.getElementById('edit-comment-modal');
        const deleteConfirmModal = document.getElementById('delete-confirm-modal');

        let currentPostId = null;

        // Post comment button
        if (postCommentBtn) {
          // Remove this duplicate event listener since we're handling it in initializeCommentPosting()
          // postCommentBtn.addEventListener('click', async function () { ... });
        }

        // Handle editing a comment
        async function handleEditComment(commentId, currentText) {
          console.log('handleEditComment called:', { commentId, currentText });

          // Show edit comment modal
          const editCommentTextarea = document.getElementById('edit-comment-text');
          const commentIdInput = document.getElementById('edit-comment-id');
          const postIdInput = document.getElementById('edit-comment-post-id');

          if (!editCommentTextarea || !commentIdInput || !postIdInput) {
            console.error('Required modal elements not found');
            return;
          }

          // Set current values
          editCommentTextarea.value = currentText;
          commentIdInput.value = commentId;
          postIdInput.value = currentPostId;

          // Show the modal
          editCommentModal.style.display = 'block';
          editCommentTextarea.focus();
        }

        // Handle deleting a comment
        async function handleDeleteComment(commentId) {
          console.log('handleDeleteComment called:', { commentId });

          // Set the comment ID in the hidden input
          const deleteCommentIdInput = document.getElementById('delete-comment-id');
          const deleteCommentPostIdInput = document.getElementById('delete-comment-post-id');

          if (!deleteCommentIdInput || !deleteCommentPostIdInput) {
            console.error('Required delete modal elements not found');
            return;
          }

          deleteCommentIdInput.value = commentId;
          deleteCommentPostIdInput.value = currentPostId;

          // Show the modal
          deleteConfirmModal.style.display = 'block';
        }

        // Setup edit comment modal functionality
        const closeEditCommentBtn = document.getElementById('close-edit-comment-modal');
        const cancelEditCommentBtn = document.getElementById('cancel-edit-comment-btn');
        const editCommentForm = document.getElementById('edit-comment-form');

        // Close edit comment modal function
        function closeEditCommentModal() {
          console.log('Closing edit comment modal');
          editCommentModal.style.display = 'none';
        }

        // Close edit comment modal when X button is clicked
        if (closeEditCommentBtn) {
          closeEditCommentBtn.addEventListener('click', closeEditCommentModal);
        }

        // Close edit comment modal when cancel button is clicked
        if (cancelEditCommentBtn) {
          cancelEditCommentBtn.addEventListener('click', closeEditCommentModal);
        }

        // Close edit comment modal when clicking outside
        window.addEventListener('click', function (e) {
          if (e.target === editCommentModal) {
            closeEditCommentModal();
          }
        });

        // Handle edit comment form submission
        if (editCommentForm) {
          editCommentForm.addEventListener('submit', async function (e) {
            e.preventDefault();
            console.log('Edit comment form submitted');

            const commentId = document.getElementById('edit-comment-id').value;
            const postId = document.getElementById('edit-comment-post-id').value;
            const commentText = document.getElementById('edit-comment-text').value.trim();

            console.log('Edit comment data:', { commentId, postId, commentText });

            if (!commentText) {
              alert('Comment cannot be empty');
              return;
            }

            try {
              // Submit the edited comment
              const response = await fetch(`/api/comments/${postId}/${commentId}`, {
                method: 'PUT',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  text: commentText
                })
              });

              if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Server returned ${response.status}: ${errorText}`);
              }

              const updatedComment = await response.json();
              console.log('Comment updated successfully:', updatedComment);

              // Update the comment in the UI
              const commentElement = document.querySelector(`.comment-item[data-comment-id="${commentId}"]`);
              if (commentElement) {
                const commentTextElement = commentElement.querySelector('.comment-text');
                const needsTruncation = commentText.length > 150;
                
                if (commentTextElement) {
                  // Remove existing classes and set them based on the new state
                  commentTextElement.className = 'comment-text';
                  if (needsTruncation) {
                    commentTextElement.classList.add('truncated-text');
                  }
                  commentTextElement.textContent = commentText;
                }

                // Handle see more button
                let seeMoreBtn = commentElement.querySelector('.comment-see-more');

                if (needsTruncation) {
                  if (!seeMoreBtn) {
                    // Create new see more button if it doesn't exist
                    seeMoreBtn = document.createElement('span');
                    seeMoreBtn.className = 'comment-see-more';
                    seeMoreBtn.textContent = 'See more...';

                    // Add see more functionality
                    seeMoreBtn.addEventListener('click', function () {
                      commentTextElement.classList.toggle('expanded');
                      this.textContent = commentTextElement.classList.contains('expanded') ? 'See less' : 'See more...';
                    });

                    // Insert after the comment text element
                    commentTextElement.after(seeMoreBtn);
                  }
                } else if (seeMoreBtn) {
                  // Remove see more button if it's not needed anymore
                  seeMoreBtn.remove();
                }
              }

              // Close the modal
              closeEditCommentModal();

            } catch (error) {
              console.error('Error updating comment:', error);
              alert(`Failed to update comment: ${error.message}`);
            }
          });
        }

        // Setup delete confirmation modal functionality
        const cancelDeleteBtn = document.getElementById('cancel-delete-btn');
        const confirmDeleteBtn = document.getElementById('confirm-delete-btn');

        // Close delete confirmation modal function
        function closeDeleteConfirmModal() {
          console.log('Closing delete confirmation modal');
          deleteConfirmModal.style.display = 'none';
        }

        // Close modal when cancel button is clicked
        if (cancelDeleteBtn) {
          cancelDeleteBtn.addEventListener('click', closeDeleteConfirmModal);
        }

        // Close modal when clicking outside
        window.addEventListener('click', function (e) {
          if (e.target === deleteConfirmModal) {
            closeDeleteConfirmModal();
          }
        });

        // Handle confirm delete button click
        if (confirmDeleteBtn) {
          confirmDeleteBtn.addEventListener('click', async function () {
            console.log('Confirm delete button clicked');
            const commentId = document.getElementById('delete-comment-id').value;
            const postId = document.getElementById('delete-comment-post-id').value;

            console.log('Delete comment data:', { commentId, postId });

            if (!commentId || !postId) {
              alert('Missing comment information');
              return;
            }

            try {
              const response = await fetch(`/api/comments/${postId}/${commentId}`, {
                method: 'DELETE',
                headers: {
                  'Content-Type': 'application/json',
                }
              });

              if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Server returned ${response.status}: ${errorText}`);
              }

              // Remove comment from UI
              const commentElement = document.querySelector(`.comment-item[data-comment-id="${commentId}"]`);
              if (commentElement) {
                commentElement.remove();

                // Update comment count
                const currentCount = parseInt(modalCommentCount.textContent.replace(/[()]/g, '')) || 0;
                const newCount = Math.max(0, currentCount - 1);
                modalCommentCount.textContent = `(${newCount})`;
                updateCommentCount(postId, newCount);

                // Show no comments message if needed
                if (newCount === 0) {
                  const noCommentsMsg = document.createElement('div');
                  noCommentsMsg.className = 'no-comments-message';
                  noCommentsMsg.textContent = 'No comments yet. Be the first to comment!';
                  commentListSection.appendChild(noCommentsMsg);
                }
              }

              // Close the modal
              closeDeleteConfirmModal();

            } catch (error) {
              console.error('Error deleting comment:', error);
              alert(`Failed to delete comment: ${error.message}`);
              closeDeleteConfirmModal();
            }
          });
        }

        // Rest of the existing comment functionality...
        commentBtns.forEach(btn => {
          btn.addEventListener('click', function () {
            const postItem = this.closest('li');
            currentPostId = postItem.dataset.postId;
            console.log('Opening comments for post:', currentPostId);
            commentModal.style.display = 'block';

            commentListSection.innerHTML = '';

            const loadingMsg = document.createElement('div');
            loadingMsg.className = 'loading-comments';
            loadingMsg.textContent = 'Loading comments';
            commentListSection.appendChild(loadingMsg);

            fetchComments(currentPostId);
          });
        });

        async function fetchComments(postId) {
          try {
            const encodedPostId = encodeURIComponent(postId);
            const response = await fetch(`/api/comments/${encodedPostId}`);

            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`Server returned ${response.status}: ${errorText}`);
            }

            const data = await response.json();

            commentListSection.innerHTML = '';

            const commentCount = data.comments ? data.comments.length : 0;
            updateCommentCount(postId, commentCount);
            modalCommentCount.textContent = `(${commentCount})`;

            if (data.comments && data.comments.length > 0) {
              data.comments.forEach(comment => {
                const commentElement = createCommentElement(comment);
                commentListSection.appendChild(commentElement);
              });
            } else {
              const noCommentsMsg = document.createElement('div');
              noCommentsMsg.className = 'no-comments-message';
              noCommentsMsg.textContent = 'No comments yet. Be the first to comment!';
              commentListSection.appendChild(noCommentsMsg);
            }
          } catch (error) {
            console.error('Error fetching comments:', error);
            commentListSection.innerHTML = `<div class="error-message">Failed to load comments: ${error.message}</div>`;
            modalCommentCount.textContent = '(0)';
          }
        }

        function closeCommentModal() {
          commentModal.style.display = 'none';
          currentPostId = null;
        }

        closeCommentBtn.addEventListener('click', closeCommentModal);
        cancelCommentBtn.addEventListener('click', closeCommentModal);

        commentModal.addEventListener('click', function (e) {
          if (e.target === commentModal) {
            closeCommentModal();
          }
        });

        // Initialize comment counts
        async function initializeCommentCounts() {
          const commentCountElements = document.querySelectorAll('.comment-count');
          commentCountElements.forEach(async countElement => {
            const postId = countElement.dataset.postId;
            if (postId) {
              try {
                const encodedPostId = encodeURIComponent(postId);
                const response = await fetch(`/api/comments/${encodedPostId}`);

                if (response.ok) {
                  const data = await response.json();
                  const commentCount = data.comments ? data.comments.length : 0;
                  countElement.textContent = commentCount;
                }
              } catch (error) {
                console.error(`Error fetching comment count for post ${postId}:`, error);
              }
            }
          });
        }

        initializeCommentCounts();
      }

      // Start both functionalities
      initializeLikeFunctionality();
      initializeCommentFunctionality();
    });

    function togglePassword(inputId) {
      const passwordInput = document.getElementById(inputId);
      const icon = document.getElementById(inputId + '-toggle-icon');
      
      if (passwordInput.type === 'password') {
        passwordInput.type = 'text';
        icon.src = '/assets/eye-off.svg';
      } else {
        passwordInput.type = 'password';
        icon.src = '/assets/eye.svg';
      }
    }
  </script>
</body>
</html>
