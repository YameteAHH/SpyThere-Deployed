<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SpyThere - Home</title>
  <link rel="stylesheet" href="home_page.css">
</head>

<body class="home-page">

  <!-- Include Header -->
  <%- include('partials/header') %>

  <!-- Page layout: Sidebar + Main Content -->
  <div class="app-layout">

    <!-- Include Sidebar (Navbar) -->
    <%- include('partials/navbar') %>

    <!-- Main Content Section -->
    <div class="main-content">
      <h2>Spy Here!</h2>

      <!-- Todo List Section -->
      <div class="todo-container">
        <ul>
          <% posts.forEach(post => { %>
            <li data-post-id="<%= post.id %>">
              <strong><%= post.username %></strong>
              <div class="post-content">
                <% if (post.value && typeof post.value==='string' && post.value.trim().length> 0) { %>
                  <div class="truncated-text">
                    <%= post.value %>
                  </div>
                  <span class="see-more-btn">See more...</span>
                  <% } %>
                    </div>
                    <% if (post.mediaUrl) { %>
                      <% if (post.mediaUrl.match(/\.(jpeg|jpg|png|gif)$/i)) { %>
                        <div class="media-container">
                          <img src="<%= post.mediaUrl %>" alt="Post media" class="post-media">
                        </div>
                        <% } else if (post.mediaUrl.match(/\.(mp4|webm|ogg)$/i)) { %>
                          <div class="media-container">
                            <video controls class="post-media">
                              <source src="<%= post.mediaUrl %>">
                              Your browser does not support the video tag.
                            </video>
                          </div>
                          <% } %>
                            <% } %>
              <div class="post-reactions">
                <div class="like-wrapper">
                  <img src="/assets/Like_Icon.png" alt="Like" class="reaction-icon like-btn" data-liked="false"
                    data-post-id="<%= post.id %>">
                  <span class="like-count" data-post-id="<%= post.id %>">0</span>
                </div>
                <div class="comment-wrapper">
                  <img src="/assets/Comment_Icon.png" alt="Comment" class="reaction-icon comment-btn">
                  <span class="comment-count" data-post-id="<%= post.id %>">0</span>
                </div>
                <img src="/assets/Share_Icon.png" alt="Share" class="reaction-icon">
                <% if (post.username===username) { %>
                  <div class="post-actions-container">
                    <img src="/assets/Edit_Icon.png" alt="Edit" class="reaction-icon edit-post-btn">
                    <img src="/assets/Delete_Icon.png" alt="Delete" class="reaction-icon delete-post-btn">
                  </div>
                  <% } %>
              </div>
            </li>
          <% }) %>
        </ul>
      </div>

      <!-- Modal for Adding Post -->
      <div id="post-modal">
        <div id="modal-content">
          <form action="/submit-post" method="post" id="post-form" enctype="multipart/form-data">
            <h1>Create to Web</h1>
            <textarea name="post" id="post" placeholder="What's on your mind..."></textarea>
            <div class="custom-file-input">
              <label class="file-input-label">
                <img src="/assets/Add_Image_Icon.png" alt="Add Image" title="Upload an image or video">
                <input type="file" name="media" accept="image/*,video/*,image/gif">
              </label>
              <span class="file-name"></span>
            </div>
            <div id="modal-btns">
              <button id="close-modal-btn" class="modal-btn" type="button">Cancel</button>
              <input type="submit" value="Post" id="post-content-btn" class="modal-btn">
            </div>
          </form>
        </div>
      </div>
      
      <!-- Modal for Comments -->
      <div class="comment-modal">
        <div class="comment-modal-content">
          <button class="close-comment-modal">×</button>
          <h3>Comments <span class="modal-comment-count">0</span></h3>
          
          <!-- Comment Input Section -->
          <div class="comment-input-section">
            <textarea placeholder="Write a comment..."></textarea>
            <div class="comment-actions">
              <button type="button" class="modal-btn">Cancel</button>
              <button type="button" class="modal-btn">Post Comment</button>
            </div>
          </div>
          
          <div class="comment-divider"></div>
          
          <!-- Comment List Section -->
          <div class="comment-list-section">
            <div class="loading-comments">Loading comments</div>
          </div>
        </div>
      </div>
      
      <!-- Modal for Likes -->
      <div class="like-modal">
        <div class="like-modal-content">
          <button class="close-like-modal">×</button>
          <h3>Likes <span class="modal-like-count">0</span></h3>
          
          <div class="like-divider"></div>
          
          <!-- Like List Section -->
          <div class="like-list-section">
            <div class="loading-likes">Loading likes</div>
          </div>
        </div>
      </div>

      <!-- Modal for Edit Comment -->
      <div id="edit-comment-modal" class="modal">
        <div class="modal-content">
          <button id="close-edit-comment-modal" class="close-modal">×</button>
          <h3>Edit Comment</h3>
          
          <form id="edit-comment-form">
            <input type="hidden" id="edit-comment-id" name="commentId">
            <input type="hidden" id="edit-comment-post-id" name="postId">
            
            <textarea id="edit-comment-text" name="text" placeholder="Edit your comment..."></textarea>
            
            <div class="modal-btns">
              <button type="button" id="cancel-edit-comment-btn" class="modal-btn">Cancel</button>
              <button type="submit" class="modal-btn">Save Changes</button>
            </div>
          </form>
        </div>
      </div>

      <!-- Modal for Delete Confirmation -->
      <div id="delete-confirm-modal" class="modal">
        <div class="modal-content">
          <h3>Delete Comment</h3>
          <p>Are you sure you want to delete this comment? This action cannot be undone.</p>
          
          <input type="hidden" id="delete-comment-id">
          <input type="hidden" id="delete-comment-post-id">
          
          <div class="delete-modal-buttons">
            <button id="cancel-delete-btn" class="modal-btn cancel-btn">Cancel</button>
            <button id="confirm-delete-btn" class="modal-btn delete-btn">Delete</button>
          </div>
        </div>
      </div>
      <!-- Modal for Developers -->
      <div id="developers-modal">
        <div id="modal-content">
          <h1>Developers</h1>
          <div class="developers-list">
            <div class="developer-item">Aiza Caballero</div>
            <div class="developer-item">Jaydee Moles</div>
            <div class="developer-item">Maria Christina Salvador</div>
            <div class="developer-item">Maverick Malala</div>
          </div>
          <div id="modal-btns">
            <button id="close-developers-modal" class="modal-btn">Close</button>
          </div>
        </div>
      </div>
<!-- Modal for Edit Post -->
<div id="edit-post-modal" class="modal">
  <div class="modal-content">
    <button id="close-edit-post-modal" class="close-modal">×</button>
    <h3>Edit Post</h3>

    <form id="edit-post-form">
      <input type="hidden" id="edit-post-id" name="postId">

      <textarea id="edit-post-text" name="text" placeholder="Edit your post..."></textarea>

      <div class="modal-btns">
        <button type="button" id="cancel-edit-post-btn" class="modal-btn">Cancel</button>
        <button type="submit" class="modal-btn">Save Changes</button>
      </div>
    </form>
  </div>
</div>

<!-- Modal for Delete Post Confirmation -->
<div id="delete-post-confirm-modal" class="modal">
  <div class="modal-content">
    <h3>Delete Post</h3>
    <p>Are you sure you want to delete this post? This action cannot be undone.</p>

    <input type="hidden" id="delete-post-id">

    <div class="delete-modal-buttons">
      <button id="cancel-delete-post-btn" class="modal-btn cancel-btn">Cancel</button>
      <button id="confirm-delete-post-btn" class="modal-btn delete-btn">Delete</button>
    </div>
  </div>
</div>
    </div>
  </div>

  <!-- Modal for Developers -->
  <div id="developers-modal">
    <div id="modal-content">
      <h1>Developers</h1>
      <div class="developers-list">
        <div class="developer-item">Maria Christina Salvador</div>
        <div class="developer-item">Jaydee Moles</div>
        <div class="developer-item">Aiza C. Caballero</div>
        <div class="developer-item">Maverick Malala</div>
      </div>
      <div id="modal-btns">
        <button id="close-developers-modal" class="modal-btn">Close</button>
      </div>
    </div>
  </div>
  <script src="/scripts/index.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      console.log('Page loaded, initializing functionality');

      // // Initialize Developers Modal functionality
      // const logo = document.querySelector('header.header .logo');
      // const developersModal = document.getElementById('developers-modal');
      // const closeDevelopersBtn = document.getElementById('close-developers-modal');

      // // Open developers modal when logo is clicked
      // if (logo) {
      //   logo.addEventListener('click', function () {
      //     developersModal.style.display = 'block';
      //   });
      // }

      // // Close developers modal when close button is clicked
      // if (closeDevelopersBtn) {
      //   closeDevelopersBtn.addEventListener('click', function () {
      //     developersModal.style.display = 'none';
      //   });
      // }

      // // Close developers modal when clicking outside
      // window.addEventListener('click', function (e) {
      //   if (e.target === developersModal) {
      //     developersModal.style.display = 'none';
      //   }
      // });
      
      // Initialize Developers Modal functionality
      const logo = document.querySelector('header.header .logo');
      const developersModal = document.getElementById('developers-modal');
      const closeDevelopersBtn = document.getElementById('close-developers-modal');
      
      // Open developers modal when logo is clicked
      if (logo) {
        logo.addEventListener('click', function() {
          developersModal.style.display = 'block';
        });
      }
      
      // Close developers modal when close button is clicked
      if (closeDevelopersBtn) {
        closeDevelopersBtn.addEventListener('click', function() {
          developersModal.style.display = 'none';
        });
      }
      
      // Close developers modal when clicking outside
      window.addEventListener('click', function(e) {
        if (e.target === developersModal) {
          developersModal.style.display = 'none';
        }
      });

      // Initialize comment functionality
      const commentBtns = document.querySelectorAll('.comment-btn');
      const commentModal = document.querySelector('.comment-modal');
      const closeCommentBtn = document.querySelector('.close-comment-modal');
      const cancelCommentBtn = document.querySelector('.comment-actions .modal-btn:first-child');
      const commentListSection = document.querySelector('.comment-list-section');
      const modalCommentCount = document.querySelector('.modal-comment-count');

      // Current post being commented on
      let currentPostId = null;

      // Open comment modal when comment icon is clicked
      commentBtns.forEach(btn => {
        btn.addEventListener('click', function () {
          const postItem = this.closest('li');
          currentPostId = postItem.dataset.postId;
          console.log('Opening comments for post:', currentPostId);
          commentModal.style.display = 'block';

          // Clear previous comments
          commentListSection.innerHTML = '';

          // Show loading indicator
          const loadingMsg = document.createElement('div');
          loadingMsg.className = 'loading-comments';
          loadingMsg.textContent = 'Loading comments';
          commentListSection.appendChild(loadingMsg);

          // Fetch comments from server for this post
          fetchComments(currentPostId);
        });
      });

      // Fetch comments from the server
      async function fetchComments(postId) {
        try {
          console.log('Fetching comments for post:', postId);
          // Encode the postId to handle special characters in the URL
          const encodedPostId = encodeURIComponent(postId);
          const response = await fetch(`/api/comments/${encodedPostId}`);

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Server returned ${response.status}: ${errorText}`);
          }

          const data = await response.json();
          console.log('Comments received:', data);

          // Clear loading message
          commentListSection.innerHTML = '';

          // Update comment counts
          const commentCount = data.comments ? data.comments.length : 0;
          updateCommentCount(postId, commentCount);
          modalCommentCount.textContent = `(${commentCount})`;

          if (data.comments && data.comments.length > 0) {
            // Display comments
            data.comments.forEach(comment => {
              const commentElement = createCommentElement(comment);
              commentListSection.appendChild(commentElement);
            });
          } else {
            // Show no comments message
            const noCommentsMsg = document.createElement('div');
            noCommentsMsg.className = 'no-comments-message';
            noCommentsMsg.textContent = 'No comments yet. Be the first to comment!';
            commentListSection.appendChild(noCommentsMsg);
          }
        } catch (error) {
          console.error('Error fetching comments:', error);
          commentListSection.innerHTML = `<div class="error-message">Failed to load comments: ${error.message}</div>`;
          modalCommentCount.textContent = '(0)';
        }
      }

      // Helper function to create comment element
      function createCommentElement(comment) {
        const commentElement = document.createElement('div');
        commentElement.className = 'comment-item';
        commentElement.dataset.commentId = comment.id;

        // Check if this comment is from the current user
        // We'll check for a match on the author name
        const isOwnComment = comment.author === '<%= username %>';

        // Add edit and delete buttons if it's the user's own comment
        const actionButtons = isOwnComment ? `
          <div class="comment-actions-container">
            <img src="/assets/Edit_Icon.png" alt="Edit" class="comment-action-icon edit-comment-btn">
            <img src="/assets/Delete_Icon.png" alt="Delete" class="comment-action-icon delete-comment-btn">
          </div>
        ` : '';
          
        // Check if comment text is longer than 150 characters
        const commentText = comment.text;
        const needsTruncation = commentText.length > 150;

        let commentHTML = `
          <div class="comment-author">${comment.author}</div>
        `;

        if (needsTruncation) {
          commentHTML += `
            <div class="comment-text truncated-text">${commentText}</div>
            <span class="comment-see-more">See more...</span>
          `;
        } else {
          commentHTML += `
            <div class="comment-text">${commentText}</div>
          `;
        }

        commentHTML += actionButtons;

        commentElement.innerHTML = commentHTML;

        // Add event listeners for edit and delete buttons if it's the user's own comment
        if (isOwnComment) {
          setTimeout(() => {
            const editBtn = commentElement.querySelector('.edit-comment-btn');
            const deleteBtn = commentElement.querySelector('.delete-comment-btn');

            if (editBtn) {
              editBtn.addEventListener('click', function () {
                handleEditComment(comment.id, comment.text);
              });
            }

            if (deleteBtn) {
              deleteBtn.addEventListener('click', function () {
                handleDeleteComment(comment.id);
              });
            }
          }, 0);
        }

        // Add see more functionality if needed
        if (needsTruncation) {
          const seeMoreBtn = commentElement.querySelector('.comment-see-more');
          const commentTextDiv = commentElement.querySelector('.comment-text');

          seeMoreBtn.addEventListener('click', function () {
            commentTextDiv.classList.toggle('expanded');
            this.textContent = commentTextDiv.classList.contains('expanded') ? 'See less' : 'See more...';
          });
        }

        return commentElement;
      }

      // Update comment count for a specific post
      function updateCommentCount(postId, count) {
        const countElement = document.querySelector(`.comment-count[data-post-id="${postId}"]`);
        if (countElement) {
          countElement.textContent = count;
        }
      }

      // Close comment modal
      function closeCommentModal() {
        commentModal.style.display = 'none';
        currentPostId = null;
      }

      closeCommentBtn.addEventListener('click', closeCommentModal);
      cancelCommentBtn.addEventListener('click', closeCommentModal);

      // Close modal when clicking outside
      commentModal.addEventListener('click', function (e) {
        if (e.target === commentModal) {
          closeCommentModal();
        }
      });

      // Handle editing a comment
      async function handleEditComment(commentId, currentText) {
        console.log('Editing comment:', commentId);

        // Show edit comment modal
        const editCommentModal = document.getElementById('edit-comment-modal');
        const editCommentTextarea = document.getElementById('edit-comment-text');
        const commentIdInput = document.getElementById('edit-comment-id');
        const postIdInput = document.getElementById('edit-comment-post-id');

        // Set current values
        editCommentTextarea.value = currentText;
        commentIdInput.value = commentId;
        postIdInput.value = currentPostId;

        // Show the modal
        editCommentModal.style.display = 'block';
        editCommentTextarea.focus();
      }

      // Handle deleting a comment
      async function handleDeleteComment(commentId) {
        console.log('Opening delete confirmation for comment:', commentId);

        // Set the comment ID in the hidden input
        document.getElementById('delete-comment-id').value = commentId;
        document.getElementById('delete-comment-post-id').value = currentPostId;

        // Show the modal
        const deleteConfirmModal = document.getElementById('delete-confirm-modal');
        deleteConfirmModal.style.display = 'block';
      }

      // Post comment button
      const postCommentBtn = document.querySelector('.comment-actions .modal-btn:last-child');
      postCommentBtn.addEventListener('click', async function () {
        const commentTextarea = document.querySelector('.comment-input-section textarea');
        const commentText = commentTextarea.value;

        if (commentText.trim() === '' || !currentPostId) {
          console.log('Empty comment or no post ID');
          return;
        }

        console.log('Posting comment to post:', currentPostId);

        try {
          // Show posting indicator
          postCommentBtn.disabled = true;
          postCommentBtn.textContent = 'Posting...';

          // Send comment to server
          const response = await fetch('/api/comments', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              postId: currentPostId,
              text: commentText
            })
          });

          console.log('Response status:', response.status);

          if (!response.ok) {
            const errorData = await response.text();
            console.error('Server error response:', errorData);
            throw new Error(`Server returned ${response.status}: ${errorData}`);
          }

          const newComment = await response.json();
          console.log('Comment posted successfully:', newComment);

          // Clear any "no comments" message
          const noCommentsMsg = commentListSection.querySelector('.no-comments-message');
          if (noCommentsMsg) {
            commentListSection.removeChild(noCommentsMsg);
          }

          // Add to UI
          const newCommentElement = createCommentElement(newComment);
          commentListSection.prepend(newCommentElement);

          // Clear the input
          commentTextarea.value = '';

          // Update comment count
          const currentCount = parseInt(modalCommentCount.textContent.replace(/[()]/g, '')) || 0;
          const newCount = currentCount + 1;
          modalCommentCount.textContent = `(${newCount})`;
          updateCommentCount(currentPostId, newCount);

        } catch (error) {
          console.error('Error posting comment:', error);
          alert(`Failed to post comment: ${error.message}`);
        } finally {
          // Reset button state
          postCommentBtn.disabled = false;
          postCommentBtn.textContent = 'Post Comment';
        }
      });

      // Initialize comment counts on page load
      function initializeCommentCounts() {
        const commentCountElements = document.querySelectorAll('.comment-count');
        commentCountElements.forEach(async countElement => {
          const postId = countElement.dataset.postId;
          if (postId) {
            try {
              const encodedPostId = encodeURIComponent(postId);
              const response = await fetch(`/api/comments/${encodedPostId}`);

              if (response.ok) {
                const data = await response.json();
                const commentCount = data.comments ? data.comments.length : 0;
                countElement.textContent = commentCount;
              }
            } catch (error) {
              console.error(`Error fetching comment count for post ${postId}:`, error);
            }
          }
        });
      }

      // Initialize comment counts when page loads
      initializeCommentCounts();

      // Setup edit comment modal functionality
      const editCommentModal = document.getElementById('edit-comment-modal');
      const closeEditCommentBtn = document.getElementById('close-edit-comment-modal');
      const cancelEditCommentBtn = document.getElementById('cancel-edit-comment-btn');
      const editCommentForm = document.getElementById('edit-comment-form');

      // Close edit comment modal function
      function closeEditCommentModal() {
        editCommentModal.style.display = 'none';
      }

      // Close edit comment modal when X button is clicked
      if (closeEditCommentBtn) {
        closeEditCommentBtn.addEventListener('click', closeEditCommentModal);
      }

      // Close edit comment modal when cancel button is clicked
      if (cancelEditCommentBtn) {
        cancelEditCommentBtn.addEventListener('click', closeEditCommentModal);
      }

      // Close edit comment modal when clicking outside
      window.addEventListener('click', function (e) {
        if (e.target === editCommentModal) {
          closeEditCommentModal();
        }
      });

      // Handle edit comment form submission
      if (editCommentForm) {
        editCommentForm.addEventListener('submit', async function (e) {
          e.preventDefault();

          const commentId = document.getElementById('edit-comment-id').value;
          const postId = document.getElementById('edit-comment-post-id').value;
          const commentText = document.getElementById('edit-comment-text').value.trim();

          if (!commentText) {
            alert('Comment cannot be empty');
            return;
          }

          try {
            // Submit the edited comment
            const response = await fetch(`/api/comments/${postId}/${commentId}`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                text: commentText
              })
            });

            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`Server returned ${response.status}: ${errorText}`);
            }

            const updatedComment = await response.json();
            console.log('Comment updated successfully:', updatedComment);

            // Update the comment in the UI
            const commentElement = document.querySelector(`.comment-item[data-comment-id="${commentId}"]`);
            if (commentElement) {
              const commentTextElement = commentElement.querySelector('.comment-text');
              const needsTruncation = commentText.length > 150;

              if (commentTextElement) {
                // Remove existing classes and set them based on the new state
                commentTextElement.className = 'comment-text';
                if (needsTruncation) {
                  commentTextElement.classList.add('truncated-text');
                }
                commentTextElement.textContent = commentText;
              }

              // Handle see more button
              let seeMoreBtn = commentElement.querySelector('.comment-see-more');

              if (needsTruncation) {
                if (!seeMoreBtn) {
                  // Create new see more button if it doesn't exist
                  seeMoreBtn = document.createElement('span');
                  seeMoreBtn.className = 'comment-see-more';
                  seeMoreBtn.textContent = 'See more...';

                  // Add see more functionality
                  seeMoreBtn.addEventListener('click', function () {
                    commentTextElement.classList.toggle('expanded');
                    this.textContent = commentTextElement.classList.contains('expanded') ? 'See less' : 'See more...';
                  });

                  // Insert after the comment text element
                  commentTextElement.after(seeMoreBtn);
                }
              } else if (seeMoreBtn) {
                // Remove see more button if it's not needed anymore
                seeMoreBtn.remove();
              }
            }

            // Close the modal
            closeEditCommentModal();

          } catch (error) {
            console.error('Error updating comment:', error);
            alert(`Failed to update comment: ${error.message}`);
          }
        });
      }

      // Like Modal Functionality - Check if like API is available
      async function checkLikeApiAvailability() {
        try {
          // Try to fetch a test like to see if the API exists
          const response = await fetch('/api/likes/test-availability');
          // Even if it's a 404 for the specific post, if we get a proper JSON response
          // with an error message about the post not found, the API itself exists
          const isAvailable = response.status !== 404 || (await response.text()).includes('Post ID');
          return isAvailable;
        } catch (error) {
          console.warn('Like API not available:', error);
          return false;
        }
      }

      // Initialize like functionality
      async function initializeLikeFunctionality() {
        // Check if the like API is available
        const isLikeApiAvailable = await checkLikeApiAvailability();
        console.log('Like API available:', isLikeApiAvailable);

        if (!isLikeApiAvailable) {
          // Hide like counts if API is not available
          document.querySelectorAll('.like-count').forEach(el => el.style.display = 'none');
          return;
        }

        const likeBtns = document.querySelectorAll('.like-btn');
        const likeModal = document.querySelector('.like-modal');
        const closeLikeBtn = document.querySelector('.close-like-modal');
        const likeListSection = document.querySelector('.like-list-section');
        const modalLikeCount = document.querySelector('.modal-like-count');

        // Current post being viewed for likes
        let currentLikePostId = null;

        // Remove any existing event listeners
        likeBtns.forEach(btn => {
          const newBtn = btn.cloneNode(true);
          btn.parentNode.replaceChild(newBtn, btn);
        });

        // Get the fresh references after replacing the buttons
        const freshLikeBtns = document.querySelectorAll('.like-btn');

        // Toggle like status when like icon is clicked
        freshLikeBtns.forEach(btn => {
          btn.addEventListener('click', async function (e) {
            e.preventDefault(); // Prevent any default behavior
            e.stopPropagation(); // Stop event propagation

            const postItem = this.closest('li');
            const postId = postItem.dataset.postId;
            const isLiked = this.dataset.liked === 'true';

            console.log('Like button clicked for post:', postId, 'Current liked status:', isLiked);

            try {
              // Send like request to server first
              const response = await fetch('/api/likes', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  postId: postId,
                  liked: !isLiked
                })
              });

              if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Server returned ${response.status}: ${errorText}`);
              }

              const data = await response.json();
              console.log('Like updated:', data);

              // Only update UI if server request was successful
              this.dataset.liked = !isLiked ? 'true' : 'false';

              // Update icon based on new like status
              if (!isLiked) {
                this.src = '/assets/Liked_Icon.png';
                this.alt = 'Unlike';
              } else {
                this.src = '/assets/Like_Icon.png';
                this.alt = 'Like';
              }

              // Update like count in UI
              updateLikeCount(postId, data.likeCount);

            } catch (error) {
              console.error('Error updating like:', error);
              alert(`Failed to update like: ${error.message}`);
            }
          });
        });

        // Show likes modal when clicking on like count
        document.querySelectorAll('.like-count').forEach(countElement => {
          countElement.addEventListener('click', function () {
            const postId = this.dataset.postId;
            currentLikePostId = postId;
            likeModal.style.display = 'block';

            // Clear previous likes
            likeListSection.innerHTML = '';

            // Show loading indicator
            const loadingMsg = document.createElement('div');
            loadingMsg.className = 'loading-likes';
            loadingMsg.textContent = 'Loading likes';
            likeListSection.appendChild(loadingMsg);

            // Fetch likes from server for this post
            fetchLikes(postId);
          });
        });

        // Fetch likes from the server
        async function fetchLikes(postId) {
          try {
            console.log('Fetching likes for post:', postId);
            const encodedPostId = encodeURIComponent(postId);
            const response = await fetch(`/api/likes/${encodedPostId}`);

            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`Server returned ${response.status}: ${errorText}`);
            }

            const data = await response.json();
            console.log('Likes received:', data);

            // Clear loading message
            likeListSection.innerHTML = '';

            // Update like counts
            const likeCount = data.likes ? data.likes.length : 0;
            updateLikeCount(postId, likeCount);
            modalLikeCount.textContent = `(${likeCount})`;

            if (data.likes && data.likes.length > 0) {
              // Display likes
              data.likes.forEach(like => {
                const likeElement = createLikeElement(like.username);
                likeListSection.appendChild(likeElement);
              });
            } else {
              // Show no likes message
              const noLikesMsg = document.createElement('div');
              noLikesMsg.className = 'no-likes-message';
              noLikesMsg.textContent = 'No likes yet. Be the first to like!';
              likeListSection.appendChild(noLikesMsg);
            }
          } catch (error) {
            console.error('Error fetching likes:', error);
            likeListSection.innerHTML = `<div class="error-message">Failed to load likes: ${error.message}</div>`;
            modalLikeCount.textContent = '(0)';
          }
        }

        // Helper function to create like element
        function createLikeElement(username) {
          const likeElement = document.createElement('div');
          likeElement.className = 'like-item';
          likeElement.innerHTML = `
            <div class="like-username">${username}</div>
          `;
          return likeElement;
        }

        // Update like count for a specific post
        function updateLikeCount(postId, count) {
          const countElement = document.querySelector(`.like-count[data-post-id="${postId}"]`);
          if (countElement) {
            countElement.textContent = count;
          }
        }

        // Close like modal
        function closeLikeModal() {
          likeModal.style.display = 'none';
          currentLikePostId = null;
        }

        closeLikeBtn.addEventListener('click', closeLikeModal);

        // Close modal when clicking outside
        likeModal.addEventListener('click', function (e) {
          if (e.target === likeModal) {
            closeLikeModal();
          }
        });

        // Initialize like counts and states on page load
        function initializeLikes() {
          const likeCountElements = document.querySelectorAll('.like-count');
          const likeBtns = document.querySelectorAll('.like-btn');

          console.log('Initializing likes for', likeCountElements.length, 'posts');

          // Process each post
          likeCountElements.forEach(async (countElement, index) => {
            const postId = countElement.dataset.postId;
            if (postId) {
              try {
                console.log('Fetching initial like data for post:', postId);
                const encodedPostId = encodeURIComponent(postId);
                const response = await fetch(`/api/likes/${encodedPostId}`);

                if (!response.ok) {
                  const errorText = await response.text();
                  console.error(`Server returned ${response.status} for post ${postId}:`, errorText);
                  return;
                }

                const data = await response.json();
                console.log('Initial like data received for post', postId, ':', data);

                // Update count
                const likeCount = data.likes ? data.likes.length : 0;
                countElement.textContent = likeCount;

                // Check if current user liked this post
                if (data.userLiked) {
                  const likeBtn = document.querySelector(`.like-btn[data-post-id="${postId}"]`) ||
                    document.querySelector(`li[data-post-id="${postId}"] .like-btn`);
                  if (likeBtn) {
                    console.log('User previously liked post:', postId, 'updating button state');
                    likeBtn.src = window.location.origin + '/assets/Liked_Icon.png';
                    likeBtn.alt = 'Unlike';
                    likeBtn.dataset.liked = 'true';
                    console.log('Set liked image:', likeBtn.src);
                  }
                }
              } catch (error) {
                console.error(`Error fetching like data for post ${postId}:`, error);
              }
            }
          });
        }

        // Initialize likes
        initializeLikes();
      }

      // Start like functionality initialization
      initializeLikeFunctionality();

      // Setup delete confirmation modal functionality
      const deleteConfirmModal = document.getElementById('delete-confirm-modal');
      const cancelDeleteBtn = document.getElementById('cancel-delete-btn');
      const confirmDeleteBtn = document.getElementById('confirm-delete-btn');

      // Close delete confirmation modal function
      function closeDeleteConfirmModal() {
        deleteConfirmModal.style.display = 'none';
      }

      // Close modal when cancel button is clicked
      if (cancelDeleteBtn) {
        cancelDeleteBtn.addEventListener('click', closeDeleteConfirmModal);
      }

      // Close modal when clicking outside
      window.addEventListener('click', function (e) {
        if (e.target === deleteConfirmModal) {
          closeDeleteConfirmModal();
        }
      });

      // Handle confirm delete button click
      if (confirmDeleteBtn) {
        confirmDeleteBtn.addEventListener('click', async function () {
          const commentId = document.getElementById('delete-comment-id').value;
          const postId = document.getElementById('delete-comment-post-id').value;

          if (!commentId || !postId) {
            alert('Missing comment information');
            return;
          }

          console.log('Deleting comment:', commentId, 'from post:', postId);

          try {
            const response = await fetch(`/api/comments/${postId}/${commentId}`, {
              method: 'DELETE',
              headers: {
                'Content-Type': 'application/json',
              }
            });

            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`Server returned ${response.status}: ${errorText}`);
            }

            // Remove comment from UI
            const commentElement = document.querySelector(`.comment-item[data-comment-id="${commentId}"]`);
            if (commentElement) {
              commentElement.remove();

              // Update comment count
              const currentCount = parseInt(modalCommentCount.textContent.replace(/[()]/g, '')) || 0;
              const newCount = Math.max(0, currentCount - 1);
              modalCommentCount.textContent = `(${newCount})`;
              updateCommentCount(postId, newCount);

              // Show no comments message if needed
              if (newCount === 0) {
                const noCommentsMsg = document.createElement('div');
                noCommentsMsg.className = 'no-comments-message';
                noCommentsMsg.textContent = 'No comments yet. Be the first to comment!';
                commentListSection.appendChild(noCommentsMsg);
              }
            }

            // Close the modal
            closeDeleteConfirmModal();

          } catch (error) {
            console.error('Error deleting comment:', error);
            closeDeleteConfirmModal();
          }
        });
      }

      // Post edit and delete functionality
      const editPostBtns = document.querySelectorAll('.edit-post-btn');
      const deletePostBtns = document.querySelectorAll('.delete-post-btn');
      const editPostModal = document.getElementById('edit-post-modal');
      const closeEditPostBtn = document.getElementById('close-edit-post-modal');
      const cancelEditPostBtn = document.getElementById('cancel-edit-post-btn');
      const editPostForm = document.getElementById('edit-post-form');
      const deletePostConfirmModal = document.getElementById('delete-post-confirm-modal');
      const cancelDeletePostBtn = document.getElementById('cancel-delete-post-btn');
      const confirmDeletePostBtn = document.getElementById('confirm-delete-post-btn');

      // Edit post functionality
      editPostBtns.forEach(btn => {
        btn.addEventListener('click', function () {
          const postItem = this.closest('li');
          const postId = postItem.dataset.postId;
          const postContent = postItem.querySelector('strong').nextSibling.textContent.trim();

          // Set up edit modal
          document.getElementById('edit-post-id').value = postId;
          document.getElementById('edit-post-text').value = postContent;

          // Show edit modal
          editPostModal.style.display = 'block';
        });
      });

      // Close edit post modal
      function closeEditPostModal() {
        editPostModal.style.display = 'none';
      }

      if (closeEditPostBtn) {
        closeEditPostBtn.addEventListener('click', closeEditPostModal);
      }

      if (cancelEditPostBtn) {
        cancelEditPostBtn.addEventListener('click', closeEditPostModal);
      }

      // Close modal when clicking outside
      window.addEventListener('click', function (e) {
        if (e.target === editPostModal) {
          closeEditPostModal();
        }
      });

      // Handle edit post form submission
      if (editPostForm) {
        editPostForm.addEventListener('submit', async function (e) {
          e.preventDefault();

          const postId = document.getElementById('edit-post-id').value;
          const postText = document.getElementById('edit-post-text').value.trim();

          if (!postText) {
            console.error('Post cannot be empty');
            return;
          }

          try {
            // Submit the edited post
            const response = await fetch(`/api/posts/${postId}`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                value: postText
              })
            });

            console.log('Edit post response status:', response.status);

            if (!response.ok) {
              const errorText = await response.text();
              console.error('Server error response:', errorText);
              throw new Error(`Server returned ${response.status}: ${errorText}`);
            }

            const updatedPost = await response.json();
            console.log('Post updated successfully:', updatedPost);

            // Update the post in the UI
            const postItem = document.querySelector(`li[data-post-id="${postId}"]`);
            if (postItem) {
              // Store the original username element
              const originalUsername = postItem.querySelector('strong').outerHTML;
              const mediaElement = postItem.querySelector('.media-container');
              const reactionsDiv = postItem.querySelector('.post-reactions');

              // Create a temporary div to hold the structure
              const tempDiv = document.createElement('div');
              tempDiv.innerHTML = originalUsername;

              // Create the post-content with truncated text and see more button
              const postContent = document.createElement('div');
              postContent.className = 'post-content';

              // Only add text and see more button if there is text content
              if (postText && postText.trim().length > 0) {
                const truncatedText = document.createElement('div');
                truncatedText.className = 'truncated-text';
                truncatedText.textContent = postText;

                const seeMoreBtn = document.createElement('span');
                seeMoreBtn.className = 'see-more-btn';
                seeMoreBtn.textContent = 'See more...';

                // If text is less than 150 characters, hide the see more button
                if (postText.length < 150) {
                  seeMoreBtn.classList.add('hidden');
                }

                // Add click event to see more button
                seeMoreBtn.addEventListener('click', function () {
                  truncatedText.classList.toggle('expanded');
                  this.textContent = truncatedText.classList.contains('expanded') ? 'See less' : 'See more...';
                });

                postContent.appendChild(truncatedText);
                postContent.appendChild(seeMoreBtn);
              }

              tempDiv.appendChild(postContent);

              // Re-add the media element if it exists
              if (mediaElement) {
                tempDiv.appendChild(mediaElement);
              }

              // Re-add the reactions div
              if (reactionsDiv) {
                tempDiv.appendChild(reactionsDiv);
              }

              // Clear the post item and add the updated content
              postItem.innerHTML = '';
              while (tempDiv.firstChild) {
                postItem.appendChild(tempDiv.firstChild);
              }
            }

            // Close the modal
            closeEditPostModal();

          } catch (error) {
            console.error('Error updating post:', error);
            closeEditPostModal();
          }
        });
      }

      // Delete post functionality
      deletePostBtns.forEach(btn => {
        btn.addEventListener('click', function () {
          const postItem = this.closest('li');
          const postId = postItem.dataset.postId;

          // Set up delete confirmation modal
          document.getElementById('delete-post-id').value = postId;

          // Show delete confirmation modal
          deletePostConfirmModal.style.display = 'block';
        });
      });

      // Close delete post confirmation modal
      function closeDeletePostModal() {
        deletePostConfirmModal.style.display = 'none';
      }

      if (cancelDeletePostBtn) {
        cancelDeletePostBtn.addEventListener('click', closeDeletePostModal);
      }

      // Close modal when clicking outside
      window.addEventListener('click', function (e) {
        if (e.target === deletePostConfirmModal) {
          closeDeletePostModal();
        }
      });

      // Handle confirm delete button click
      if (confirmDeletePostBtn) {
        confirmDeletePostBtn.addEventListener('click', async function () {
          const postId = document.getElementById('delete-post-id').value;

          if (!postId) {
            console.error('Missing post information');
            return;
          }

          console.log('Sending delete request for post:', postId);
          const response = await fetch(`/api/posts/${postId}`, {
            method: 'DELETE',
            headers: {
              'Content-Type': 'application/json',
            }
          });

          console.log('Delete post response status:', response.status);

          if (!response.ok) {
            const errorText = await response.text();
            console.error('Server error response:', errorText);
            throw new Error(`Server returned ${response.status}: ${errorText}`);
          }

          const result = await response.json();
          console.log('Post deleted successfully:', result);

          // Remove post from UI
          const postItem = document.querySelector(`li[data-post-id="${postId}"]`);
          if (postItem) {
            postItem.remove();
          }

          // Close the modal
          closeDeletePostModal();

        });
      }

      // Helper function to initialize event listeners for a post
      function initializePostEventListeners(postItem) {
        // Like button - Remove this section since we handle likes in initializeLikeFunctionality
        const likeBtn = postItem.querySelector('.like-btn');
        if (likeBtn) {
          // Remove any existing click listeners
          const newLikeBtn = likeBtn.cloneNode(true);
          likeBtn.parentNode.replaceChild(newLikeBtn, likeBtn);
        }

        // Comment button
        const commentBtn = postItem.querySelector('.comment-btn');
        if (commentBtn) {
          commentBtn.addEventListener('click', function () {
            const postId = postItem.dataset.postId;
            currentPostId = postId;
            commentModal.style.display = 'block';

            // Clear previous comments
            commentListSection.innerHTML = '';

            // Show loading indicator
            const loadingMsg = document.createElement('div');
            loadingMsg.className = 'loading-comments';
            loadingMsg.textContent = 'Loading comments';
            commentListSection.appendChild(loadingMsg);

            // Fetch comments from server for this post
            fetchComments(postId);
          });
        }

        // Edit button
        const editBtn = postItem.querySelector('.edit-post-btn');
        if (editBtn) {
          editBtn.addEventListener('click', function () {
            const postId = postItem.dataset.postId;
            const postContent = postItem.querySelector('strong').nextSibling.textContent.trim();

            document.getElementById('edit-post-id').value = postId;
            document.getElementById('edit-post-text').value = postContent;

            editPostModal.style.display = 'block';
          });
        }

        // Delete button
        const deleteBtn = postItem.querySelector('.delete-post-btn');
        if (deleteBtn) {
          deleteBtn.addEventListener('click', function () {
            const postId = postItem.dataset.postId;

            document.getElementById('delete-post-id').value = postId;
            deletePostConfirmModal.style.display = 'block';
          });
        }
      }

      // Initialize event listeners for all posts
      document.querySelectorAll('li[data-post-id]').forEach(postItem => {
        initializePostEventListeners(postItem);
      });
    });
  </script>
</body>

</html>
